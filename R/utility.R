

#' @name genConvs
#' @description Get converged simulates from a resMSE object
#' @export
get.converged <- function(mse, convyears = "all", convhcrs = "all", out = 0, verbose = FALSE){

    nhcr <- length(mse)
    hcrs <- names(mse)
    nrep <- length(mse[[1]])
    nquant <- length(mse[[1]][[1]])
    nysim <- nrow(mse[[1]][[1]]$tacs)
    dims <- dim(mse[[1]][[1]]$CW)
    ny <- dims[1] - nysim
    ns <- dims[2]

    if(!is.na(convyears[1]) && convyears[1] == "all")
        convyears <- 1:nysim
    if(!is.na(convhcrs[1]) && convhcrs[1] == "all")
        convhcrs <- 1:nhcr

    if(is.numeric(convyears[1]) && is.numeric(convhcrs[1])){
        indlist <- vector("list",nhcr)
        for(hcr in 1:nhcr){
            tmp <- do.call(rbind,lapply(mse[[hcr]], function(x) x[["tacs"]]$conv))
            indlist[[hcr]] <- apply(tmp[,convyears], 1, all)
        }
        ## across hcrs only
        indlist2 <- do.call(cbind,indlist[convhcrs])

        ## ## across hcrs and scens
        ## tmp <- lapply(indlist, function(x) do.call(cbind,x[convhcrs]))
        ## tmp2 <- do.call(cbind, tmp)
        ## print(5*length(which(apply(tmp2, 1, all))))
        inds <- which(apply(indlist2,1,all))

        if(verbose)
            writeLines(paste0("Converged reps: ",length(inds), " of ",nrep,
                              " reps = ",round(length(inds)/nrep*100),"%"))
        res <- vector("list",nhcr)
        for(hcr in 1:nhcr){
            if(hcrs[hcr] != "refFmsy"){
            res[[hcr]] <- mse[[hcr]][inds]
            names(res[[hcr]]) <- inds
            }else{
                res[[hcr]] <- mse[[hcr]]
            names(res[[hcr]]) <- 1:nrep
            }
        }
    }else if(!is.na(convyears[1])){
        res <- vector("list",nhcr)
        for(hcr in 1:nhcr){
            tmpid <- unlist(lapply(strsplit(as.character(mse[[hcr]][[1]]$tacs$id),"-"), "[[", 1))
            if(any(tmpid %in% c("Bref","Bref2"))){
                id <- mse[[hcr]][[1]]$tacs$id[which(tmpid %in% c("Bref","Bref2"))[1]]
            }else{
                if(length(unique(mse[[hcr]][[1]]$tacs$id)) > 1){ ## TODO: find better solution to this
                    id <- unique(mse[[hcr]][[1]]$tacs$id)[which(!unique(mse[[hcr]][[1]]$tacs$id) %in% c("conscat","r23","r12","r35"))]
                }else{
                    id <- unique(mse[[hcr]][[1]]$tacs$id)
                }
            }
            if(id == 1) browser()
            print(id)
            id2 <- unlist(strsplit(as.character(id), "-"))[1]
            if(!(id2 %in% c("noF","refFmsy","r11","r12","r23","r35"))){
                tmp <- do.call(rbind,lapply(mse[[hcr]], function(x) x[["tacs"]]$conv))
                inds <- which(apply(tmp[,convyears], 1, all))
            }else inds <- 1:nrep
            if(verbose)
                writeLines(paste0("Converged reps: ",length(inds), " of ",nrep,
                                  " reps = ",round(length(inds)/nrep*100),"%"))
            res[[hcr]] <- mse[[hcr]][inds]
            names(res[[hcr]]) <- inds
        }
    }else{
        res <- vector("list",nhcr)
        for(hcr in 1:nhcr){
            res[[hcr]] <- mse[[hcr]]
            names(res[[hcr]]) <- 1:nrep
        }
    }


    ## return
    if(out == 0){
        return(res)
    }else if(out == 1){
        return(sapply(res, length))
    }

}


#' @name sdconv
#' @export
sdconv <- function(mu, sd) (log(1 + ((sd^2)/(mu^2))))^0.5


#' @name muconv
#' @export
muconv <- function(mu, sd) log(mu) - 0.5 * log(1 + ((sd^2)/(mu^2)))


#' @name gen.noise
#' @export
gen.noise <- function(n, sd, rho=0, bias.cor = 0, mv=FALSE, dat=NULL){

    if(mv){
        ## multivariate noise
        stopifnot(!is.null(dat))
        amax <- dat$amax + 1
        Sigma <- matrix(NA, amax, amax)
        for(i in 1:amax) for(j in 1:amax) Sigma[i,j] = rho^abs(i - j) * sd^2
        res <- MASS::mvrnorm(n, rep(0,ncol(Sigma)), Sigma)
        if(bias.cor == 1){
            for(i in 1:amax) res[,i] <- res[,i] - Sigma[i,i] / 2
        }else if(bias.cor != 0) stop("bias.cor has to be 0 or 1 for multivariate noise. Please check set$noiseCmult and set$noiseImult.")
        res <- exp(res)
    }else{
        if(bias.cor == 0){
            rnoise <- rnorm(n, 0, sd)
        }else if(bias.cor == 1){
            rnoise <- rnorm(n, 0, sd) - sd^2/2
        }else if(bias.cor == 2){
            rnoise <- log(rlnorm(n, muconv(1,sd), sdconv(1,sd)))
        }else stop("bias.cor has to be 0, 1, or 2. Please check the different set$noise* settings.")

        if(rho > 0){
            res <- numeric(n)
            res[1] <- rnoise[1]
            if(n > 1){
                for(i in 2:n) res[i] <- rho * res[i-1] + sqrt(1 - rho^2) * rnoise[i]
            }

            res <- exp(res)
            res <- res/mean(res)

        }else{
            res <- exp(rnoise)
        }
    }
    return(res)
}


#' @name est.depletion
#' @export
est.depletion <- function(dat, set=NULL, fmax = 10, nrep = 100, verbose = TRUE, method = "percentile"){

    if(!any(names(dat) == "ref")) stop("Reference points are missing in dat. Use est.ref.levels.stochastic to estimate reference points.")

    if(is.null(set)){
        set <- check.set()
        nrep <- 1
    }

    depl <- dat$depl
    depl.quant <- dat$depl.quant
    depl.prob <- dat$depl.prob

    if(depl.quant %in% c("Bmsy","Blim")){
        outopt <- 2
    }else if(depl.quant %in% c("SSBmsy","SSBlim")){
        outopt <- 3
    }else stop("depl.quant not implemented. Please use Bmsy, Blim,SSBmsy or SSBlim. Or implement others.")

    frel <- dat$FM/max(dat$FM)

    fn <- function(logfabs, frel, depl, depl.prob, nrep, dat, set, outopt, optFn=1){
        datx <- dat
        fpat <- frel * exp(logfabs)
        datx$FM <- fpat
        dreal <- sapply(1:nrep, function(x) initpop(datx, set, out.opt = outopt))
        if(method == "mean"){
            drealQ <- mean(dreal)
        }else if(method == "median"){
            drealQ <- quantile(dreal, probs = 0.5)
        }else if(method == "percentile"){
            drealQ <- quantile(dreal, probs = depl.prob)
        }
        if(optFn==1) return((depl - drealQ)^2)
        if(optFn==2) return(drealQ)
    }

    opt <- optimize(fn, c(log(0.0001),log(fmax)), frel = frel, depl = depl, depl.prob = depl.prob,
                    nrep = nrep, dat = dat, set=set, outopt = outopt, optFn = 1)
    fabs <- exp(opt$minimum)
    fvals <- frel * fabs
    dreal <- round(fn(log(fabs), frel, depl, depl.prob, nrep, dat, set, outopt=outopt, optFn = 2),3)

    if(verbose){
        print(paste0("Target depletion level as ",depl.prob * 100, "% quantile of ", depl, " ", depl.quant,
                     " -- Realised depletion level at ", dreal, " ", depl.quant,
                     " with absolute F equal to ",round(fabs,3)))
    }

    dat$FM <- fvals

    return(dat)
}



#' @name est.productivity
#' @export
est.productivity <- function(dat, set= NULL,
                    ny = 100,
                    fmax = 10,
                    tsSplit = 8,
                    plot = TRUE){

    dat$ny <- ny
    ns <- dat$ns
    nt <- ny * ns

    ## noise
    if(is.null(set)) set <- check.set()
    set$noiseF <- c(0,0,0)
    set$noiseR <- c(0,0,0)
    set$noiseR0 <- c(0,0,0)
    set$noiseH <- c(0,0,0)
    set$noiseM <- c(0,0,0)
    set$noiseW <- c(0,0,0)
    set$noiseMat <- c(0,0,0)
    set$noiseSel <- c(0,0,0)
    set$noiseImp <- c(0,0,0)


    ##
    len1 <- len3 <- floor(ny/tsSplit)
    len2 <- ny - len1 - len3

    ## increasing effort
    dat$FM <- c(rep(0,len1),
                   seq(0, fmax, length.out = len2),
                rep(fmax,len3)) / ns
    ## CHECK: how to estimate productivity with time variant M?
    dat$M <- mean(dat$M)
    dat <- check.dat(dat)
    pop1 <- initpop(dat, set)
    tsb1 <- pop1$TSBfinal
    esb1 <- pop1$ESBfinal
    cw1 <- apply(pop1$CW,1,sum)
    prod1 <- rep(NA, ny)
    if(set$spType == 0){
        for(i in 2:ny){
            prod1[i] <- tsb1[i] - tsb1[i-1] + cw1[i]
        }
    }else if(set$spType == 1){
        for(i in 2:ny){
            prod1[i] <- esb1[i] - esb1[i-1] + cw1[i]
        }
    }

    ## est blim as fraction of B corresponding to 0.5 MSY (ICES WKBUT 2013, Cadrin 1999)
    msy1 <- max(prod1, na.rm=TRUE)
    Blim1 <- tsb1[which.min(abs(prod1 - msy1/2))]

    ## decreasing effort
    dat$FM <- c(rep(fmax, len1),
                   seq(fmax, 0, length.out = len2),
                rep(0, len3)) / ns
    dat$M <- mean(dat$M)
    dat <- check.dat(dat)
    pop2 <- initpop(dat, set)
    tsb2 <- pop2$TSBfinal
    esb2 <- pop2$ESBfinal
    cw2 <- apply(pop2$CW,1,sum)
    prod2 <- rep(NA, ny)
    if(set$spType == 0){
        for(i in 2:ny){
            prod2[i] <- tsb2[i] - tsb2[i-1] + cw2[i]
        }
    }else if(set$spType == 1){
        for(i in 2:ny){
            prod2[i] <- esb2[i] - esb2[i-1] + cw2[i]
        }
    }


    if(plot){

        plot(tsb1, prod1, ty='n',
             xlim = range(0,tsb1,tsb2),
             ylim = range(0,prod1,prod2,na.rm=TRUE))
        lines(tsb1, prod1, ty='b',
              col = "dodgerblue2")
        lines(tsb2, prod2, ty='b',
              col = "darkgreen")
        legend("topright",
               title = "Effort",
               legend = c("increasing","decreasing"),
               lty=1, col = c("dodgerblue2","darkgreen"))

        if(FALSE){
        plot(tsb1/refs$B0, prod1/refs$MSY, ty='n',
             xlim = c(0,1.05), ylim = c(0,1.5))
        lines(tsb1/refs$B0, prod1/refs$MSY, ty='b',
              col = "dodgerblue2")
        lines(tsb2/refs$B0, prod2/refs$MSY, ty='b',
              col = "darkgreen")
        legend("topright",
               title = "Effort",
               legend = c("increasing","decreasing"),
               lty=1, col = c("dodgerblue2","darkgreen"))
        }

        ## abs plot
        ## plot(tsb1/refs$B0, prod1, ty='n',
        ##      xlim = c(0,1), ylim = range(prod1,prod2,na.rm=TRUE))
        ## lines(tsb1/refs$B0, prod1, ty='b',
        ##       col = "dodgerblue2")
        ## lines(tsb2/refs$B0, prod2, ty='b',
        ##       col = "darkgreen")
    }

    ## CHECK: different production curves as a results of different age/length composition of stock (not at equilibrium age composition at given F, because F changes to quickly. If F changes small -> two curves are the same!

    res <- list(
        Blim = Blim1,
        incr = data.frame(tsb = tsb1,
                          esb = esb1,
                          cw = cw1,
                          prod = prod1),
        decr = data.frame(tsb = tsb2,
                          esb = esb2,
                          cw = cw2,
                          prod = prod2)
    )

    return(res)

}



#' @name est.productivity
#' @export
est.productivity.stochastic <- function(dat, set= NULL,
                         fmax = 10,
                         nf = 1e3,
                         prob = c(0.1,0.9),
                         ncores = parallel::detectCores()-1,
                         plot = TRUE){

    amax <- dat$amax + 1
    ny <- dat$ny
    ns <- dat$ns
    nt <- ny * ns
    asmax <- amax * ns
    ## noise
    if(is.null(set)) set <- check.set()
    nyref <- set$refYears
    nrep <- set$refN
    nyrefmsy <- set$refYearsMSY

    ##CHECK: set$noiseR <- c(dat$sigmaR, dat$rhoR, 1)
    dist <- NULL
    if(!(set$refMethod %in% c("mean","median"))){
        stop("'set$refMethod' not known! Has to be 'mean' or 'median'!")
    }

    ## errors (have to be re-used for estimation of Bmsy)
    errs <- vector("list", nrep)
    for(i in 1:nrep){
        errs[[i]] <- vector("list", 7)
        errs[[i]]$eF <- gen.noise(nyref, set$noiseF[1], set$noiseF[2], set$noiseF[3])
        errs[[i]]$eR <- gen.noise(nyref, set$noiseR[1], set$noiseR[2], set$noiseR[3])
        errs[[i]]$eM <- gen.noise(nyref, set$noiseM[1], set$noiseM[2], set$noiseM[3])
        errs[[i]]$eH <- gen.noise(nyref, set$noiseH[1], set$noiseH[2], set$noiseH[3])
        errs[[i]]$eW <- gen.noise(nyref, set$noiseW[1], set$noiseW[2], set$noiseW[3])
        errs[[i]]$eR0 <- gen.noise(nyref, set$noiseR0[1], set$noiseR0[2], set$noiseR0[3])
        errs[[i]]$eMat <- gen.noise(nyref, set$noiseMat[1], set$noiseMat[2], set$noiseMat[3])
        errs[[i]]$eSel <- gen.noise(nyref, set$noiseSel[1], set$noiseSel[2], set$noiseSel[3])
        errs[[i]]$eImp <- gen.noise(nyref, set$noiseImp[1], set$noiseImp[2], set$noiseImp[3])
    }

    datx <- dat
    ## ##
    ## datx$yvec <- rep(1:nyref, each = ns)
    ## datx$svec <- rep(1:ns, each = nyref)
    ## datx$s1vec <- seq(1, nyref * ns, ns)
    ## datx$as2a <- rep(1:amax, each = ns)
    ## datx$as2s <- rep(1:ns, amax)
    ## datx$inds <- seq(1,asmax,ns)

    ## natural mortality
    ms <- NULL
    for(i in 1:ns){
        tmp0 <- unique(dat$M[,i])
        if(is.null(ms) || length(tmp0) == nrow(ms)){
            ms <- cbind(ms,tmp0)
        }else if(length(tmp0) == 1){
            ms <- cbind(ms,rep(tmp0, length.out = ns))
        }else stop("You are natural mortality (M) is time-variant but M does not vary consitently among seasons. Please review dat$M or contact the package maintainer.")
    }
    mtv <- nrow(ms)
    mind <- match(dat$M[,1], ms[,1])
    ## M selectivity
    if(length(dat$Msel) > 1){
        msels <- dat$Msel[!duplicated(dat$Msel)]
        mseltv <- length(msel)
    }else{
        msels <- dat$Msel[1]
        mseltv <- 1
    }
    if(mseltv > 1 && mseltv != mtv) stop("Both natural mortality over time (dat$M) and over age (dat$Msel) are time-variant, but do not have the same dimensions. This is not yet implemented, please let both vary equally or keep one of them constant.")
    alltv <- max(c(mtv, mseltv))
    ## selectivity
    if(length(dat$sel) > 1){
        sels <- dat$sel[!duplicated(dat$sel)]
        seltv <- length(sel)
    }else{
        sels <- dat$sel[1]
        seltv <- 1
    }
    if(seltv > 1 && alltv > 1 && seltv != alltv) stop("Both gear selectivity (dat$sel) and natural mortality (dat$M or dat$Msel) are time-variant, but do not have the same dimensions. This is not yet implemented, please let both vary equally or keep one of them constant.")
    alltv <- max(c(alltv,seltv))

    if(alltv > 1){
        if(mtv == alltv){
            mtv <- 1:mtv
        }else mtv <- rep(mtv, length.out = alltv)
        if(mseltv == alltv){
            mseltv <- 1:mseltv
        }else mseltv <- rep(mseltv, length.out = alltv)
        if(seltv == alltv){
            seltv <- 1:seltv
        }else seltv <- rep(seltv, length.out = alltv)
    }


    ##
    blims <- vector("list",alltv)
    means <- vector("list",alltv)
    meds <- vector("list",alltv)
    lo <- vector("list",alltv)
    up <- vector("list",alltv)
    for(i in 1:alltv){
        datx$M <- t(as.matrix(ms[mtv[i],]))
        datx$Msel <- msels[mseltv[i]]
        datx$sel <- sels[seltv[i]]
        fms <- seq(0, fmax, length.out = nf)
        tmp2 <- vector("list", nf)
        for(fx in 1:nf){
            tmp0 <- parallel::mclapply(as.list(1:nrep), function(x){
                setx <- c(set, errs[[x]])
                pop <- simpop(log(fms[fx]), datx, setx, out=0)
                tsb <- tail(pop$TSB,1)
                esb <- tail(pop$ESB,1)
                ssb <- tail(pop$SSB,1)
                cw <- tail(pop$CW,1)
                sp <- tail(pop$SP,1)
                return(c(TSB = tsb, SSB = ssb, ESB = esb, CW = cw, SP = sp))
            }, mc.cores = ncores)
            tmp1 <- do.call(rbind, tmp0)
            tmp2[[fx]] <- cbind(f = rep(fms[fx],nrep), tmp1)
        }

        ## est blim as fraction of B corresponding to 0.5 MSY (ICES WKBUT 2013, Cadrin 1999)
        bs <- do.call(rbind, lapply(tmp2, function(x) x[,2]))
        sps <- do.call(rbind, lapply(tmp2, function(x) x[,6]))
        blims[[i]] <- rep(NA, nrep)
        for(j in 1:nrep){
            msy <- max(sps[,j], na.rm=TRUE)
            blims[[i]][j] <- bs[which.min(abs(sps[,j] - msy/2)),i]
        }

        means[[i]] <- as.data.frame(do.call(rbind,lapply(tmp2,
                                                    function(x) apply(x,2, mean, na.rm=TRUE))))
        meds[[i]] <- as.data.frame(do.call(rbind,lapply(tmp2,
                                                   function(x) apply(x,2, median, na.rm=TRUE))))
        lo[[i]] <- as.data.frame(do.call(rbind,lapply(tmp2,
                                                 function(x) apply(x,2, quantile, prob=min(prob),
                                                                   na.rm=TRUE))))
        up[[i]] <- as.data.frame(do.call(rbind,lapply(tmp2,
                                                 function(x) apply(x,2, quantile, prob=max(prob),
                                                                   na.rm=TRUE))))
    }


    if(plot){
        cols <- rep(c("darkred","dodgerblue","darkgreen","darkorange","purple","gray","black","goldenrod"),100)
        plot(meds[[1]]$TSB, meds[[1]]$SP, ty = 'n',
             ylim = range(sapply(meds,function(x) x$SP),
                          sapply(lo,function(x) x$SP),
                          sapply(up,function(x) x$SP), na.rm =TRUE),
             xlim = range(sapply(meds,function(x) x$TSB),
                          sapply(lo,function(x) x$TSB),
                          sapply(up,function(x) x$TSB), na.rm =TRUE),
             xlab = "TSB", ylab = "SP")
        for(i in 1:alltv){
            if(i <= 3){
                polygon(c(lo[[i]]$TSB, rev(up[[i]]$TSB)), c(lo[[i]]$SP, rev(up[[i]]$SP)), border = NA,
                        col = rgb(t(col2rgb(cols[i])/255), alpha = 0.2))
            }
            lines(meds[[i]]$TSB, meds[[i]]$SP, col=cols[i], lwd=2)
        }
        legend("topright",
               legend = c("M = 0.2", "M = 0.3"),  ## CHECK: adjust
               col = cols[1:alltv],
               lwd = 1.5)
    }

    res <- list(meds = meds,
                means = means,
                lo = lo,
                up = up,
                blims = blims)
    return(res)

}


#' @name fpat
#' @export
fpat <- function(fmax, fscen = 1){
    fscen <- as.character(fscen)
    switch(fscen,
           "1" = {  ## flat
               fs <- c(rep(0,20),                               ## no fishing - burn-in
                       seq(0, fmax, length.out = 10),           ## increasing effort
                       rep(fmax, 20))                           ## flat
           },
           "2" = {  ## decreasing
               fs <- c(rep(0,20),                               ## no fishing - burn-in
                       seq(0, fmax, length.out = 10),           ## increasing effort
                       rep(fmax, 10),                           ## flat
                       seq(fmax, 0.6 * fmax, length.out = 10))  ## decreasing effort
           },
           "3" = {  ## increasing
               fs <- c(rep(0,20),                               ## no fishing - burn-in
                       seq(0, fmax, length.out = 10),           ## increasing effort
                       rep(fmax, 10),                           ## flat
                       seq(fmax, 1.4 * fmax, length.out = 10))  ## increasing effort
           })
    return(fs)
}



#' @name baranov
#' @export
baranov <- function(F, M, N){
    Z <- F + M
    return(F/Z * N * (1 - exp(-Z)))
}


#' @name predCatch
#'
#' @param seasons vector with season indices
#' @param ns number of seasons
#' @param h steepness
#'
#' @details get predicted catch for TAC period or difference between provided
#'     and predicted catch
predCatch <- function(logFM,
                      NAA, MAA,
                      sel, weight,
                      seasons, ns, y, h2, asmax, mat, pzbm, spawning,
                      R0, SR, bp, recBeta, recGamma, eR,
                      indage0,
                      TAC = NULL,
                      out = 0){
    Ctmp <- 0
    NAAtmp <- NAA

    for(s in seasons){
        FAA <- exp(logFM) * sel
        Ztmp <- FAA + MAA
        ## recruitment
        if(spawning[s] > 0 && s > 1){
            ## Survivors from previous season/year
            SSBPR0 <- get.ssbpr(Ztmp, mat, weight,
                                fecun=1, asmax, ns, spawning, indage0)
            SSBtmp <- sum(NAA * weight  * mat  * exp(-pzbm * Ztmp))
            rec <- recfunc(h = h2, SSBPR0 = SSBPR0, SSB = SSBtmp,
                             R0 = R0, method = SR, bp = bp,
                             beta = recBeta, gamma = recGamma)
            rec[rec<0] <- 1e-10
            NAAtmp[1] <- rec * spawning[s] * eR
        }
        Ctmp <- Ctmp + sum(baranov(FAA, MAA, NAAtmp) * weight)
        ## Aging
        NAAtmp <- NAAtmp * exp(-Ztmp)
        NAAtmp[asmax] <- NAAtmp[asmax] + NAAtmp[asmax-1]
        for(as in (asmax-1):2) NAAtmp[as] <- NAAtmp[as-1]
        NAAtmp[1] <- 0
    }

    if(out == 0){
        return(Ctmp)
    }else{
        return((TAC - Ctmp)^2)
    }
}

#' @name get.f
#' @details get FM accounting for seasons
#' @export
get.f <- function(TAC,
                   NAA, MAA,
                   sel, weight,
                   seasons, ns, y, h, asmax, mat,
                   pzbm, spawning,
                   R0, SR, bp, recBeta,
                  recGamma, eR,
                  indage0,
                  lastFM = 0.1){

    opt <- nlminb(start = log(lastFM), objective = predCatch,
                  NAA = NAA, MAA = MAA,
                  sel = sel, weight = weight,
                  seasons = seasons, ns = ns, y = y,
                  h2 = h, asmax = asmax, mat = mat,
                  pzbm = pzbm, spawning = spawning,
                  R0 = R0, SR = SR, bp = bp, recBeta = recBeta,
                  recGamma = recGamma, eR = eR,
                  indage0 = indage0,
                  TAC = TAC,
                  out = 1,
                  lower = -10, upper = 10,
                  control = list(rel.tol = 1e-10))
    return(exp(opt$par))
}


#' @name getSel
#' @description Function to estimate selectivity ogive
#' @param L50 - length at 50% selectivity
#' @param L95 - length at 95% selectivity
#' @param mids - midlengths
#' @param plba - probability of being in mids given age
getSel <- function(L50, L95, mids, plba){
    n <- max(c(length(L50),length(L95)))
    sel <- vector("list", n)
    for(i in 1:n){
        selL <- (1 /(1 + exp(-log(19)*(mids - L50[i])/(L95[i] - L50[i]))))
        dims <- dim(plba)
        selA <- matrix(NA, ncol = dims[3], nrow = dims[1])
        for(j in 1:dim(plba)[3]){
            selA[,j] <- apply(t(plba[,,j]) * selL, 2, sum)
        }
        ##    selA <- apply(t(plba) * selL, 2, sum)
        ##    selA[1] <- 1e-9 # it should be zero for age 0
        sel[[i]] <- selA
    }
    return(sel)
}


#' @name getMat
#' @description Function to estimate maturity at age
#' @param Lm50 - length at 50% maturity
#' @param Lm95 - length at 95% maturity
#' @param mids - midlengths
#' @param plba - probability of being in mids given age
getMat <- function(Lm50, Lm95, mids, plba){
    ## maturity at length
    matL <- (1 /(1 + exp(-log(19)*(mids - Lm50)/(Lm95 - Lm50))))
    ## maturity at age
    dims <- dim(plba)
    matA <- matrix(NA, ncol = dims[3], nrow = dims[1])
    for(i in 1:dim(plba)[3]){
        matA[,i] <- apply(t(plba[,,i]) * matL, 2, sum)
    }
##    matA <- apply(t(plba) * matL, 2, sum)
##    matA <- c(1e-9,matA[-1])
    return(matA)
}


#' @name getM
#' @description Function to estimate selectivity of natural mortality
#' @param Linf - Linf of vBGF
#' @param K - K of vBGF
#' @param mids - midlengths
getM <- function(Linf, K, mids, a = 0.55, b = 1.61, c = 1.44){
    n <- max(c(length(a),length(b),length(c)))
    maxM <- rep(NA, n)
    for(i in 1:n){
        selL <- exp(a[i] - b[i] * log(mids) + c[i] * log(Linf) + log(K))
        selL[mids < 10] <- exp(a[i] - b[i] * log(10) + c[i] * log(Linf) + log(K))
        selL <- round(selL, 3)
        maxM[i] <- max(selL)
    }
    return(maxM)
}


#' @name getMsel
#' @description Function to estimate selectivity of natural mortality
#' @param Linf - Linf of vBGF
#' @param K - K of vBGF
#' @param mids - midlengths
#' @param plba - probability of being in mids given age
getMsel <- function(Linf, K, mids, plba, a = 0.55, b = 1.61, c = 1.44){
    n <- max(c(length(a),length(b),length(c)))
    sel <- vector("list", n)
    for(i in 1:n){
        selL <- exp(a[i] - b[i] * log(mids) + c[i] * log(Linf) + log(K))
        selL[mids < 10] <- exp(a[i] - b[i] * log(10) + c[i] * log(Linf) + log(K))
        dims <- dim(plba)
        selA <- matrix(NA, ncol = dims[3], nrow = dims[1])
        for(j in 1:dim(plba)[3]){
            selA[,j] <- apply(t(plba[,,j]) * selL, 2, sum)
        }
        maxM <- max(selA)
        sel[[i]] <- selA/maxM
    }
    return(sel)
}




#' @name get.ssb0
#' @description Function to calculate SSB (F=0)
#' @param Z - total mortality
#' @param mat - maturity ogive
#' @param fecun - fecundity matrix
#' @param amax - number of age classes
#' @return spawning biomass per recruit
#' @export
get.ssb0 <- function (M, mat, weight, fecun = 1,
                       asmax, ns, spawning,
                      R0, indage0, season, FM=NULL){

    if(is.null(FM)){
        FM <- 0
    }
    ZAA <-  M + FM

    NAAS <- initdistR(M, FM=FM, ns, asmax, indage0, spawning, R0)

    ## SSB0 season dependent
    while(season > 1){
        NAAS <- NAAS * exp(-ZAA)
        NAAS[asmax] <- NAAS[asmax] + NAAS[asmax-1]
        for(as in (asmax-1):2) NAAS[as] <- NAAS[as-1]
        season <- season - 1
    }

    ## SSB0
    SBB0 <- sum(NAAS * mat * weight * fecun)

    return(SBB0)
}


#' @name recfunc
#' @description Function to calculate recruitment (Beverton - Holt)
#' @param h - steepness
#' @param R0 - recruitment in unfished population
#' @param SSBPR0 - spawning biomass produced by one recrut in its lifetime
#' @param SSB - spawning biomass
#' @param bp - breakpoint for hockey-stick SR
#' @param method - SR type
#'
#' @export
recfunc <- function(h, SSBPR0, SSB,  R0 = 1e6, method = "bevholt", bp = 0,
                    beta = 0, gamma = 0){

    if(method == "bevholt"){
        alpha <- SSBPR0 * (1-h)/(4*h)
        beta <- (5*h-1) / (4*h*R0)
        rec <- SSB / (alpha + beta * SSB)
    }else if(method == "ricker"){
        ## beta <- log(5 * h) / (0.8 * R0)
        ## alpha <- exp(beta * R0)/SSBPR0
        ## rec <- alpha * SSB * exp(-beta * SSB)
        rec <- bp * SSB * exp(-beta * SSB)
    }else if(method == "average"){
        rec <- rep(R0, length(SSB))
    }else if(method == "hockey-stick"){
        rec <- ifelse(SSB > bp, R0, SSB * R0/bp)
    }else if(method == "bent-hyperbola"){  ## Watts-Bacon bent hyperbola
        rec <- beta * (SSB + sqrt(bp^2 + (gamma^2)/4) - sqrt((SSB-bp)^2 + (gamma^2)/4))
    }else print("Stock-recruitment method not known! Implemented methods: 'bevholt', 'ricker', 'average', and 'hockey-stick'.")

    return (rec)
}



#' @name initdistR
#' @export
initdistR <- function(M, FM=NULL, ns, asmax, indage0, spawning, R0=1){

    if(is.null(FM)){
        FM <- 0
    }

    NAA2 <- NAA <- matrix(0, asmax, ns)
    NAA[indage0,] <- R0 * spawning
    ZAA <-  M + FM

    ## each season
    for(as in (indage0+1):asmax)
        NAA[as,] <- NAA[as-1,] * exp(-ZAA[as-1])
    ## only keep age groups present relative to end of year (last season)
    for(s in 1:ns){
        indi <- seq(ns+2-s+indage0-1,asmax,ns)
##         indi <- seq(s+indage0-1,asmax,ns)
        NAA2[indi,s] <- NAA[indi,s]
    }
    ## keep last age group for every season
    indi <- which(NAA2[asmax,]==0)
    NAA2[asmax,indi] <- NAA[asmax,indi] * exp(-ZAA[asmax])
    ## plus group correction
    NAA2[asmax,] <- NAA2[asmax,] / (1 - exp(-sum(ZAA[(asmax-ns+1):asmax])))
    ## combine seasons
    NAAS <- rowSums(NAA2)
    ## remove recruits
    NAAS[indage0] <- 0

    return(NAAS)
}
